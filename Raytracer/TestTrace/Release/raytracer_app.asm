; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	d:\Development\Source\Raytracer\TestTrace\raytracer_app.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_C@_1CK@FDMHKDGK@?$AAR?$AAa?$AAy?$AAT?$AAr?$AAa?$AAc?$AAe?$AAr?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CC@NIBKJCGP@?$AAR?$AAa?$AAy?$AA?5?$AAt?$AAr?$AAa?$AAc?$AAi?$AAn?$AAg?$AA?5?$AAt?$AAe?$AAs?$AAt?$AA?$AA@ ; `string'
PUBLIC	??0TestTracer@@QAE@HH@Z				; TestTracer::TestTracer
PUBLIC	?SetImage@TestTracer@@QAEXPAE@Z			; TestTracer::SetImage
PUBLIC	?GetImageWidth@TestTracer@@QBEHXZ		; TestTracer::GetImageWidth
PUBLIC	?GetImageHeight@TestTracer@@QBEHXZ		; TestTracer::GetImageHeight
PUBLIC	??0?$allocator@M@std@@QAE@ABV01@@Z		; std::allocator<float>::allocator<float>
PUBLIC	??0?$_Vector_val@MV?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z ; std::_Vector_val<float,std::allocator<float> >::_Vector_val<float,std::allocator<float> >
PUBLIC	??0?$allocator@M@std@@QAE@XZ			; std::allocator<float>::allocator<float>
PUBLIC	??$_Allocate@M@std@@YAPAMIPAM@Z			; std::_Allocate<float>
PUBLIC	?allocate@?$allocator@M@std@@QAEPAMI@Z		; std::allocator<float>::allocate
PUBLIC	?max_size@?$allocator@M@std@@QBEIXZ		; std::allocator<float>::max_size
PUBLIC	?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float> >::max_size
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	??_Glength_error@std@@UAEPAXI@Z			; std::length_error::`scalar deleting destructor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
PUBLIC	?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z	; std::char_traits<char>::_Move_s
PUBLIC	??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ; std::_Traits_helper::move_s<std::char_traits<char> >
PUBLIC	??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ; std::_Traits_helper::move_s<std::char_traits<char> >
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ ; std::_Char_traits_cat<std::char_traits<char> >
PUBLIC	?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z	; std::char_traits<char>::_Copy_s
PUBLIC	??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ; std::_Traits_helper::copy_s<std::char_traits<char> >
PUBLIC	??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ; std::_Traits_helper::copy_s<std::char_traits<char> >
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ ; std::vector<float,std::allocator<float> >::_Xlen
PUBLIC	?_Buy@?$vector@MV?$allocator@M@std@@@std@@IAE_NI@Z ; std::vector<float,std::allocator<float> >::_Buy
PUBLIC	??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ	; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
PUBLIC	?deallocate@?$allocator@M@std@@QAEXPAMI@Z	; std::allocator<float>::deallocate
PUBLIC	??$_Ptr_cat@PAMPAM@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAM0@Z ; std::_Ptr_cat<float *,float *>
PUBLIC	??$_Destroy_range@MV?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<float,std::allocator<float> >
PUBLIC	??$_Destroy_range@MV?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z ; std::_Destroy_range<float,std::allocator<float> >
PUBLIC	?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z ; std::vector<float,std::allocator<float> >::_Destroy
PUBLIC	?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ ; std::vector<float,std::allocator<float> >::_Tidy
PUBLIC	??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ	; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
PUBLIC	?tracer@@3PAVTestTracer@@A			; tracer
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__imp__QueryPerformanceCounter@4:PROC
EXTRN	__imp__QueryPerformanceFrequency@4:PROC
EXTRN	__imp__BitBlt@36:PROC
EXTRN	__imp__DeleteDC@4:PROC
EXTRN	__imp__DeleteObject@4:PROC
EXTRN	__imp__GetMessageW@16:PROC
EXTRN	__imp__DispatchMessageW@4:PROC
EXTRN	__imp__PeekMessageW@20:PROC
EXTRN	__imp__RegisterClassExW@4:PROC
EXTRN	__imp__CreateWindowExW@48:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__UpdateWindow@4:PROC
EXTRN	__imp__AdjustWindowRect@12:PROC
EXTRN	__imp__SetRect@20:PROC
EXTRN	__imp__LoadCursorW@8:PROC
EXTRN	__imp__LoadIconW@8:PROC
EXTRN	__imp__CreateCompatibleDC@4:PROC
EXTRN	__imp__SelectObject@8:PROC
EXTRN	__imp__CreateDIBSection@24:PROC
EXTRN	__imp__GetDC@4:PROC
EXTRN	__imp__DefWindowProcW@16:PROC
EXTRN	__imp__PostQuitMessage@4:PROC
EXTRN	__imp__DestroyWindow@4:PROC
EXTRN	__imp__DialogBoxParamW@20:PROC
EXTRN	__imp__BeginPaint@8:PROC
EXTRN	__imp__EndPaint@8:PROC
EXTRN	__imp__EndDialog@8:PROC
EXTRN	_atexit:PROC
EXTRN	??0exception@std@@QAE@XZ:PROC			; std::exception::exception
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	?_Xran@_String_base@std@@SAXXZ:PROC		; std::_String_base::_Xran
EXTRN	_memmove_s:PROC
EXTRN	?_Xlen@_String_base@std@@SAXXZ:PROC		; std::_String_base::_Xlen
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
EXTRN	_memcpy_s:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
?tracer@@3PAVTestTracer@@A DD 01H DUP (?)		; tracer
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB DD 0ffffffffH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
CONST	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@FDMHKDGK@?$AAR?$AAa?$AAy?$AAT?$AAr?$AAa?$AAc?$AAe?$AAr?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@FDMHKDGK@?$AAR?$AAa?$AAy?$AAT?$AAr?$AAa?$AAc?$AAe?$AAr?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?$AA@ DB 'R'
	DB	00H, 'a', 00H, 'y', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'r', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'w', 00H, 'C', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@NIBKJCGP@?$AAR?$AAa?$AAy?$AA?5?$AAt?$AAr?$AAa?$AAc?$AAi?$AAn?$AAg?$AA?5?$AAt?$AAe?$AAs?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@NIBKJCGP@?$AAR?$AAa?$AAy?$AA?5?$AAt?$AAr?$AAa?$AAc?$AAi?$AAn?$AAg?$AA?5?$AAt?$AAe?$AAs?$AAt?$AA?$AA@ DB 'R'
	DB	00H, 'a', 00H, 'y', 00H, ' ', 00H, 't', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 't', 00H, 'e'
	DB	00H, 's', 00H, 't', 00H, 00H, 00H		; `string'
_szTitle DD	FLAT:??_C@_1CC@NIBKJCGP@?$AAR?$AAa?$AAy?$AA?5?$AAt?$AAr?$AAa?$AAc?$AAi?$AAn?$AAg?$AA?5?$AAt?$AAe?$AAs?$AAt?$AA?$AA@
_szWindowClass DD FLAT:??_C@_1CK@FDMHKDGK@?$AAR?$AAa?$AAy?$AAT?$AAr?$AAa?$AAc?$AAe?$AAr?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?$AA@
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 124  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 125  : 		{	// construct by copying (do nothing)
; 126  : 		}

	ret	4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\xstring
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z PROC ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 471  : 		}

	ret	4
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 141  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 142  : 		}

	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 441  : //		_DEBUG_POINTER(_First);
; 442  : 		return (::strlen(_First));

	mov	eax, DWORD PTR __First$[esp-4]
	lea	edx, DWORD PTR [eax+1]
$LL3@length:
	mov	cl, BYTE PTR [eax]
	add	eax, 1
	test	cl, cl
	jne	SHORT $LL3@length
	sub	eax, edx

; 443  : 		}

	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2055 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx+4]

; 2056 : 		}

	ret	0
$LN3@Myptr:

; 2055 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	lea	eax, DWORD PTR [ecx+4]

; 2056 : 		}

	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1599 : 		return (_Mysize);

	mov	eax, DWORD PTR [ecx+20]

; 1600 : 		}

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2050 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	jb	SHORT $LN3@Myptr@2
	mov	eax, DWORD PTR [ecx+4]

; 2051 : 		}

	ret	0
$LN3@Myptr@2:

; 2050 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	lea	eax, DWORD PTR [ecx+4]

; 2051 : 		}

	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 166  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 167  : 		return (0 < _Count ? _Count : 1);

	or	eax, -1

; 168  : 		}

	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1604 : 		size_type _Num = _Mybase::_Alval.max_size();
; 1605 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	eax, -2					; fffffffeH

; 1606 : 		}

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 418  : 		_Left = _Right;

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	cl, BYTE PTR [eax]
	mov	edx, DWORD PTR __Left$[esp-4]
	mov	BYTE PTR [edx], cl

; 419  : 		}

	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 1993 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	mov	eax, DWORD PTR __Newsize$[esp-4]
	mov	DWORD PTR [ecx+20], eax
	jb	SHORT $LN5@Eos
	mov	ecx, DWORD PTR [ecx+4]
	mov	BYTE PTR [ecx+eax], 0

; 1994 : 		}

	ret	4

; 1993 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

$LN5@Eos:
	mov	BYTE PTR [ecx+eax+4], 0

; 1994 : 		}

	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size_in_bytes$ = 12					; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z PROC	; std::char_traits<char>::_Copy_s, COMDAT

; 456  : //		_DEBUG_POINTER(_First1);
; 457  : //		_DEBUG_POINTER(_First2);
; 458  : 		_CRT_SECURE_MEMCPY(_First1, _Size_in_bytes, _First2, _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	mov	edx, DWORD PTR __Size_in_bytes$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_memcpy_s
	add	esp, 16					; 00000010H

; 459  : 		return _First1;

	mov	eax, esi
	pop	esi

; 460  : 		}

	ret	0
?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z ENDP	; std::char_traits<char>::_Copy_s
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size_in_bytes$ = 12					; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z PROC	; std::char_traits<char>::_Move_s, COMDAT

; 480  : //		_DEBUG_POINTER(_First1);
; 481  : //		_DEBUG_POINTER(_First2);
; 482  : 		_CRT_SECURE_MEMMOVE(_First1, _Size_in_bytes, _First2, _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	mov	edx, DWORD PTR __Size_in_bytes$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H

; 483  : 		return _First1;

	mov	eax, esi
	pop	esi

; 484  : 		}

	ret	0
?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z ENDP	; std::char_traits<char>::_Move_s
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\exception
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 339  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 340  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 348  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 349  : 		}

	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@MV?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@MV?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<float,std::allocator<float> >, COMDAT

; 243  : 	}

	ret	0
??$_Destroy_range@MV?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<float,std::allocator<float> >
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAMPAM@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAM0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PAMPAM@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAM0@Z PROC ; std::_Ptr_cat<float *,float *>, COMDAT

; 1291 : 	{

	push	ecx

; 1292 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1293 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1294 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAMPAM@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAM0@Z ENDP ; std::_Ptr_cat<float *,float *>
_TEXT	ENDS
EXTRN	__CxxThrowException@8:PROC
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\xmemory
;	COMDAT ??$_Allocate@M@std@@YAPAMIPAM@Z
_TEXT	SEGMENT
$T34430 = -16						; size = 4
$T34422 = -12						; size = 12
??$_Allocate@M@std@@YAPAMIPAM@Z PROC			; std::_Allocate<float>, COMDAT
; __Count$ = ecx

; 38   : 	if (_Count <= 0)
; 39   : 		_Count = 0;
; 40   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 4
	jae	SHORT $LN1@Allocate

; 41   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T34430[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T34422[esp+20]
	mov	DWORD PTR $T34430[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T34422[esp+20]
	push	ecx
	mov	DWORD PTR $T34422[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate:
$LN1@Allocate:

; 42   : 
; 43   : 		// allocate storage for _Count elements of type _Ty
; 44   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 45   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate:
??$_Allocate@M@std@@YAPAMIPAM@Z ENDP			; std::_Allocate<float>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@MV?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@MV?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z PROC ; std::_Destroy_range<float,std::allocator<float> >, COMDAT

; 226  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 227  : 	}

	ret	0
??$_Destroy_range@MV?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z ENDP ; std::_Destroy_range<float,std::allocator<float> >
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
___formal$ = 24						; size = 1
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z PROC ; std::_Traits_helper::move_s<std::char_traits<char> >, COMDAT

; 617  : 		return _Traits::_Move_s(_First1, _Size, _First2, _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	mov	edx, DWORD PTR __Size$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H
	mov	eax, esi
	pop	esi

; 618  : 	}

	ret	0
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ENDP ; std::_Traits_helper::move_s<std::char_traits<char> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
___formal$ = 24						; size = 1
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z PROC ; std::_Traits_helper::copy_s<std::char_traits<char> >, COMDAT

; 590  : 		return _Traits::_Copy_s(_First1, _Size, _First2, _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	mov	edx, DWORD PTR __Size$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_memcpy_s
	add	esp, 16					; 00000010H
	mov	eax, esi
	pop	esi

; 591  : 	}

	ret	0
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ENDP ; std::_Traits_helper::copy_s<std::char_traits<char> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ
_TEXT	SEGMENT
__Secure$ = -1						; size = 1
??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ PROC ; std::_Char_traits_cat<std::char_traits<char> >, COMDAT

; 568  : 	{

	push	ecx

; 569  : 		typename _Char_traits_category<_Traits>::_Secure_char_traits _Secure;
; 570  : 		return (_Secure);

	mov	al, BYTE PTR __Secure$[esp+4]

; 571  : 	}

	pop	ecx
	ret	0
??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ ENDP ; std::_Char_traits_cat<std::char_traits<char> >
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2012 : 		{	// test if _Ptr points inside string

	push	esi

; 2013 : 		_DEBUG_POINTER(_Ptr);
; 2014 : 		if (_Ptr < _Myptr() || _Myptr() + _Mysize <= _Ptr)

	mov	esi, DWORD PTR [ecx+24]
	cmp	esi, 16					; 00000010H
	push	edi
	lea	eax, DWORD PTR [ecx+4]
	jb	SHORT $LN8@Inside
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN9@Inside
$LN8@Inside:
	mov	edx, eax
$LN9@Inside:
	mov	edi, DWORD PTR __Ptr$[esp+4]
	cmp	edi, edx
	jb	SHORT $LN2@Inside
	cmp	esi, 16					; 00000010H
	jb	SHORT $LN12@Inside
	mov	eax, DWORD PTR [eax]
$LN12@Inside:
	mov	ecx, DWORD PTR [ecx+20]
	add	ecx, eax
	cmp	ecx, edi
	jbe	SHORT $LN2@Inside
	pop	edi

; 2016 : 		else
; 2017 : 			return (true);

	mov	al, 1
	pop	esi

; 2018 : 		}

	ret	4
$LN2@Inside:
	pop	edi

; 2015 : 			return (false);	// don't ask

	xor	al, al
	pop	esi

; 2018 : 		}

	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 120  : 	allocator() _THROW0()

	mov	eax, ecx

; 121  : 		{	// construct default allocator (do nothing)
; 122  : 		}

	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@M@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@M@std@@QBEIXZ PROC		; std::allocator<float>::max_size, COMDAT

; 166  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 167  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 168  : 		}

	ret	0
?max_size@?$allocator@M@std@@QBEIXZ ENDP		; std::allocator<float>::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@M@std@@QAEPAMI@Z
_TEXT	SEGMENT
?allocate@?$allocator@M@std@@QAEPAMI@Z PROC		; std::allocator<float>::allocate, COMDAT

; 146  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 147  : 		}

	ret	0
?allocate@?$allocator@M@std@@QAEPAMI@Z ENDP		; std::allocator<float>::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@M@std@@QAEXPAMI@Z
_TEXT	SEGMENT
?deallocate@?$allocator@M@std@@QAEXPAMI@Z PROC		; std::allocator<float>::deallocate, COMDAT
; __Ptr$ = eax

; 141  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 142  : 		}

	ret	0
?deallocate@?$allocator@M@std@@QAEXPAMI@Z ENDP		; std::allocator<float>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@M@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@M@std@@QAE@ABV01@@Z PROC			; std::allocator<float>::allocator<float>, COMDAT

; 125  : 		{	// construct by copying (do nothing)
; 126  : 		}

	mov	eax, OFFSET _g_fpsValues
	ret	0
??0?$allocator@M@std@@QAE@ABV01@@Z ENDP			; std::allocator<float>::allocator<float>
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z PROC ; std::vector<float,std::allocator<float> >::_Destroy, COMDAT

; 1083 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1084 : 		}

	ret	0
?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z ENDP ; std::vector<float,std::allocator<float> >::_Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ PROC ; std::vector<float,std::allocator<float> >::max_size, COMDAT

; 708  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 709  : 		}

	ret	0
?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ENDP ; std::vector<float,std::allocator<float> >::max_size
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@M@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@M@std@@QAE@XZ PROC			; std::allocator<float>::allocator<float>, COMDAT
; _this$ = eax

; 121  : 		{	// construct default allocator (do nothing)
; 122  : 		}

	ret	0
??0?$allocator@M@std@@QAE@XZ ENDP			; std::allocator<float>::allocator<float>
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@MV?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@MV?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z PROC ; std::_Vector_val<float,std::allocator<float> >::_Vector_val<float,std::allocator<float> >, COMDAT

; 413  : 		}

	mov	eax, OFFSET _g_fpsValues
	ret	4
??0?$_Vector_val@MV?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z ENDP ; std::_Vector_val<float,std::allocator<float> >::_Vector_val<float,std::allocator<float> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ PROC	; std::vector<float,std::allocator<float> >::_Tidy, COMDAT

; 1088 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _g_fpsValues+4
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1089 : 			{	// something to free, destroy and deallocate it
; 1090 : 
; 1091 :  #if _HAS_ITERATOR_DEBUGGING
; 1092 : 			this->_Orphan_all();
; 1093 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1094 : 
; 1095 : 			_Destroy(_Myfirst, _Mylast);
; 1096 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1097 : 			}
; 1098 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR _g_fpsValues+4, 0
	mov	DWORD PTR _g_fpsValues+8, 0
	mov	DWORD PTR _g_fpsValues+12, 0

; 1099 : 		}

	ret	0
?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ ENDP	; std::vector<float,std::allocator<float> >::_Tidy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ PROC	; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >, COMDAT

; 546  : 		_Tidy();

	mov	eax, DWORD PTR _g_fpsValues+4
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR _g_fpsValues+4, 0
	mov	DWORD PTR _g_fpsValues+8, 0
	mov	DWORD PTR _g_fpsValues+12, 0

; 547  : 		}

	ret	0
??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ENDP	; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
_TEXT	ENDS
PUBLIC	?About@@YGHPAUHWND__@@IIJ@Z			; About
; Function compile flags: /Ogtpy
; File d:\development\source\raytracer\testtrace\raytracer_app.cpp
;	COMDAT ?About@@YGHPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_hDlg$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?About@@YGHPAUHWND__@@IIJ@Z PROC			; About, COMDAT

; 184  : 	switch (message) {

	mov	eax, DWORD PTR _message$[esp-4]
	sub	eax, 272				; 00000110H
	je	SHORT $LN4@About
	sub	eax, 1
	jne	SHORT $LN2@About

; 187  : 
; 188  : 	case WM_COMMAND:
; 189  : 		if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) {

	mov	eax, DWORD PTR _wParam$[esp-4]
	cmp	ax, 1
	je	SHORT $LN1@About
	cmp	ax, 2
	je	SHORT $LN1@About
$LN2@About:

; 191  : 			return (INT_PTR)TRUE;
; 192  : 		}
; 193  : 		break;
; 194  : 	}
; 195  : 	return (INT_PTR)FALSE;

	xor	eax, eax

; 196  : }

	ret	16					; 00000010H
$LN1@About:

; 190  : 			EndDialog(hDlg, LOWORD(wParam));

	mov	ecx, DWORD PTR _hDlg$[esp-4]
	movzx	eax, ax
	push	eax
	push	ecx
	call	DWORD PTR __imp__EndDialog@8
$LN4@About:

; 185  : 	case WM_INITDIALOG:
; 186  : 		return (INT_PTR)TRUE;

	mov	eax, 1

; 196  : }

	ret	16					; 00000010H
?About@@YGHPAUHWND__@@IIJ@Z ENDP			; About
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?WndProc@@YGJPAUHWND__@@IIJ@Z			; WndProc
EXTRN	___security_cookie:DWORD
_g_hInstance DD	01H DUP (?)
; Function compile flags: /Ogtpy
;	COMDAT ?WndProc@@YGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_ps$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
_hWnd$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?WndProc@@YGJPAUHWND__@@IIJ@Z PROC			; WndProc, COMDAT

; 146  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+76], eax

; 147  : 	int wmId, wmEvent;
; 148  : 	PAINTSTRUCT ps;
; 149  : 	HDC hdc;
; 150  : 
; 151  : 	switch (message) {

	mov	ecx, DWORD PTR _message$[ebp]
	mov	eax, ecx
	sub	eax, 2
	push	esi
	mov	esi, DWORD PTR _hWnd$[ebp]
	je	$LN2@WndProc
	sub	eax, 13					; 0000000dH
	je	$LN3@WndProc
	sub	eax, 258				; 00000102H
	je	SHORT $LN9@WndProc

; 174  : 		break;
; 175  : 	default:
; 176  : 		return DefWindowProc(hWnd, message, wParam, lParam);

	mov	eax, DWORD PTR _lParam$[ebp]
	mov	edx, DWORD PTR _wParam$[ebp]
	push	eax
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__DefWindowProcW@16

; 179  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[esp+76]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN9@WndProc:

; 152  : 	case WM_COMMAND:
; 153  : 		wmId    = LOWORD(wParam);
; 154  : 		wmEvent = HIWORD(wParam);
; 155  : 		// Parse the menu selections:
; 156  : 		switch (wmId) {

	mov	ecx, DWORD PTR _wParam$[ebp]
	movzx	eax, cx
	sub	eax, 104				; 00000068H
	je	SHORT $LN6@WndProc
	sub	eax, 1
	je	SHORT $LN5@WndProc

; 162  : 			break;
; 163  : 		default:
; 164  : 			return DefWindowProc(hWnd, message, wParam, lParam);

	mov	eax, DWORD PTR _lParam$[ebp]
	push	eax
	push	ecx
	push	273					; 00000111H
	push	esi
	call	DWORD PTR __imp__DefWindowProcW@16

; 179  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[esp+76]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN5@WndProc:

; 159  : 			break;
; 160  : 		case IDM_EXIT:
; 161  : 			DestroyWindow(hWnd);

	push	esi
	call	DWORD PTR __imp__DestroyWindow@4

; 177  : 	}
; 178  : 	return 0;

	xor	eax, eax

; 179  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[esp+76]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN6@WndProc:

; 157  : 		case IDM_ABOUT:
; 158  : 			DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);

	mov	ecx, DWORD PTR _g_hInstance
	push	0
	push	OFFSET ?About@@YGHPAUHWND__@@IIJ@Z	; About
	push	esi
	push	103					; 00000067H
	push	ecx
	call	DWORD PTR __imp__DialogBoxParamW@20

; 177  : 	}
; 178  : 	return 0;

	xor	eax, eax

; 179  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[esp+76]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN3@WndProc:

; 165  : 		}
; 166  : 		break;
; 167  : 	case WM_PAINT:
; 168  : 		hdc = BeginPaint(hWnd, &ps);

	lea	edx, DWORD PTR _ps$[esp+80]
	push	edx
	push	esi
	call	DWORD PTR __imp__BeginPaint@8

; 169  : 		// TODO: Add any drawing code here...
; 170  : 		EndPaint(hWnd, &ps);

	lea	eax, DWORD PTR _ps$[esp+80]
	push	eax
	push	esi
	call	DWORD PTR __imp__EndPaint@8

; 177  : 	}
; 178  : 	return 0;

	xor	eax, eax

; 179  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[esp+76]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN2@WndProc:

; 171  : 		break;
; 172  : 	case WM_DESTROY:
; 173  : 		PostQuitMessage(0);

	push	0
	call	DWORD PTR __imp__PostQuitMessage@4

; 179  : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+80]
	pop	esi
	xor	ecx, esp
	xor	eax, eax
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?WndProc@@YGJPAUHWND__@@IIJ@Z ENDP			; WndProc
_TEXT	ENDS
PUBLIC	?RenderImage@TestTracer@@QAEXXZ			; TestTracer::RenderImage
; Function compile flags: /Ogtpy
; File d:\development\source\raytracer\testtrace\testtracer.h
;	COMDAT ?RenderImage@TestTracer@@QAEXXZ
_TEXT	SEGMENT
?RenderImage@TestTracer@@QAEXXZ PROC			; TestTracer::RenderImage, COMDAT

; 33   :   }

	ret	0
?RenderImage@TestTracer@@QAEXXZ ENDP			; TestTracer::RenderImage
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetImageHeight@TestTracer@@QBEHXZ
_TEXT	SEGMENT
?GetImageHeight@TestTracer@@QBEHXZ PROC			; TestTracer::GetImageHeight, COMDAT

; 20   :     int GetImageHeight() const { return m_imageHeight; }

	mov	eax, DWORD PTR ?tracer@@3PAVTestTracer@@A ; tracer
	mov	eax, DWORD PTR [eax+8]
	ret	0
?GetImageHeight@TestTracer@@QBEHXZ ENDP			; TestTracer::GetImageHeight
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetImageWidth@TestTracer@@QBEHXZ
_TEXT	SEGMENT
?GetImageWidth@TestTracer@@QBEHXZ PROC			; TestTracer::GetImageWidth, COMDAT

; 19   :     int GetImageWidth() const { return m_imageWidth; }

	mov	eax, DWORD PTR ?tracer@@3PAVTestTracer@@A ; tracer
	mov	eax, DWORD PTR [eax+4]
	ret	0
?GetImageWidth@TestTracer@@QBEHXZ ENDP			; TestTracer::GetImageWidth
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?SetImage@TestTracer@@QAEXPAE@Z
_TEXT	SEGMENT
?SetImage@TestTracer@@QAEXPAE@Z PROC			; TestTracer::SetImage, COMDAT
; _image$ = ecx

; 16   :       m_image = image;

	mov	eax, DWORD PTR ?tracer@@3PAVTestTracer@@A ; tracer
	mov	DWORD PTR [eax], ecx

; 17   :       }

	ret	0
?SetImage@TestTracer@@QAEXPAE@Z ENDP			; TestTracer::SetImage
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0TestTracer@@QAE@HH@Z
_TEXT	SEGMENT
??0TestTracer@@QAE@HH@Z PROC				; TestTracer::TestTracer, COMDAT
; _this$ = eax

; 10   :       {
; 11   :       m_imageWidth=w;

	mov	ecx, 400				; 00000190H
	mov	DWORD PTR [eax+4], ecx

; 12   :       m_imageHeight=h;

	mov	DWORD PTR [eax+8], ecx

; 13   :       }

	ret	0
??0TestTracer@@QAE@HH@Z ENDP				; TestTracer::TestTracer
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1584 : 		return (_Myptr());

	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	jb	SHORT $LN5@c_str
	mov	eax, DWORD PTR [ecx+4]

; 1585 : 		}

	ret	0

; 1584 : 		return (_Myptr());

$LN5@c_str:
	lea	eax, DWORD PTR [ecx+4]

; 1585 : 		}

	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\stdexcept
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 36   : 		return (_Str.c_str());

	cmp	DWORD PTR [ecx+36], 16			; 00000010H
	jb	SHORT $LN7@what
	mov	eax, DWORD PTR [ecx+16]

; 37   : 		}

	ret	0

; 36   : 		return (_Str.c_str());

$LN7@what:
	lea	eax, DWORD PTR [ecx+16]

; 37   : 		}

	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z PROC ; std::_Traits_helper::move_s<std::char_traits<char> >, COMDAT

; 609  : 		return move_s<_Traits>(_First1, _Size, _First2, _Count, _Char_traits_cat<_Traits>());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	mov	edx, DWORD PTR __Size$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H
	mov	eax, esi
	pop	esi

; 610  : 	}

	ret	0
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ENDP ; std::_Traits_helper::move_s<std::char_traits<char> >
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
tv130 = 8						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1202 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebx

; 1203 : 		if (_Mysize < _Off)

	mov	ebx, DWORD PTR __Off$[esp]
	push	esi
	mov	esi, ecx
	cmp	DWORD PTR [esi+20], ebx
	push	edi
	jae	SHORT $LN3@erase

; 1204 : 			_String_base::_Xran();	// _Off off end

	call	?_Xran@_String_base@std@@SAXXZ		; std::_String_base::_Xran
$LN3@erase:

; 1205 : 		if (_Mysize - _Off < _Count)

	mov	eax, DWORD PTR [esi+20]
	mov	edi, DWORD PTR __Count$[esp+8]
	sub	eax, ebx
	cmp	eax, edi
	jae	SHORT $LN2@erase

; 1206 : 			_Count = _Mysize - _Off;	// trim _Count

	mov	edi, eax
$LN2@erase:

; 1207 : 		if (0 < _Count)

	test	edi, edi
	jbe	SHORT $LN30@erase

; 1208 : 			{	// move elements down
; 1209 : 			_Traits_helper::move_s<_Traits>(_Myptr() + _Off, _Myres - _Off, _Myptr() + _Off + _Count,
; 1210 : 				_Mysize - _Off - _Count);

	mov	ecx, DWORD PTR [esi+24]
	cmp	ecx, 16					; 00000010H
	push	ebp
	lea	ebp, DWORD PTR [esi+4]
	jb	SHORT $LN8@erase
	mov	edx, DWORD PTR [ebp]
	mov	DWORD PTR tv130[esp+12], edx
	jmp	SHORT $LN9@erase
$LN8@erase:
	mov	DWORD PTR tv130[esp+12], ebp
$LN9@erase:
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN12@erase
	mov	edx, DWORD PTR [ebp]
	jmp	SHORT $LN13@erase
$LN12@erase:
	mov	edx, ebp
$LN13@erase:
	sub	eax, edi
	push	eax
	mov	eax, DWORD PTR tv130[esp+16]
	add	eax, ebx
	add	eax, edi
	push	eax
	sub	ecx, ebx
	push	ecx
	add	edx, ebx
	push	edx
	call	_memmove_s

; 1211 : 			size_type _Newsize = _Mysize - _Count;

	mov	eax, DWORD PTR [esi+20]
	sub	eax, edi
	add	esp, 16					; 00000010H

; 1212 : 			_Eos(_Newsize);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], eax
	jb	SHORT $LN26@erase
	mov	ebp, DWORD PTR [ebp]
$LN26@erase:
	mov	BYTE PTR [eax+ebp], 0
	pop	ebp
$LN30@erase:
	pop	edi

; 1213 : 			}
; 1214 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1215 : 		}

	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
$T34691 = -12						; size = 12
$T34695 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 38   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@2

; 39   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@2:

; 42   : 
; 43   : 		// allocate storage for _Count elements of type _Ty
; 44   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 45   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@2:

; 40   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 1
	jae	SHORT $LN1@Allocate@2

; 41   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T34695[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T34691[esp+16]
	mov	DWORD PTR $T34695[esp+12], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T34691[esp+16]
	push	ecx
	mov	DWORD PTR $T34691[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@2:
$LN8@Allocate@2:
	int	3
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
$T34712 = -12						; size = 12
$T34706 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 146  : 		return (_Allocate(_Count, (pointer)0));

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN5@allocate
	xor	ecx, ecx
$LN3@allocate:
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 147  : 		}

	add	esp, 12					; 0000000cH
	ret	4

; 146  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 1
	jae	SHORT $LN3@allocate
	lea	eax, DWORD PTR $T34706[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T34712[esp+16]
	mov	DWORD PTR $T34706[esp+12], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T34712[esp+16]
	push	ecx
	mov	DWORD PTR $T34712[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate:
$LN11@allocate:
	int	3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z PROC ; std::_Traits_helper::copy_s<std::char_traits<char> >, COMDAT

; 582  : 		return copy_s<_Traits>(_First1, _Size, _First2, _Count, _Char_traits_cat<_Traits>());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	mov	edx, DWORD PTR __Size$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_memcpy_s
	add	esp, 16					; 00000010H
	mov	eax, esi
	pop	esi

; 583  : 	}

	ret	0
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ENDP ; std::_Traits_helper::copy_s<std::char_traits<char> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_g_bitmap DD	01H DUP (?)
_g_memDC DD	01H DUP (?)
_g_hWnd	DD	01H DUP (?)
; Function compile flags: /Ogtpy
; File d:\development\source\raytracer\testtrace\raytracer_app.cpp
;	COMDAT ?CreateMainImage@@YA_NXZ
_TEXT	SEGMENT
_image$ = -48						; size = 4
_info$ = -44						; size = 44
?CreateMainImage@@YA_NXZ PROC				; CreateMainImage, COMDAT

; 66   : 	g_memDC = CreateCompatibleDC(GetDC(g_hWnd));

	mov	eax, DWORD PTR _g_hWnd
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	mov	edi, DWORD PTR __imp__GetDC@4
	push	eax
	call	edi
	push	eax
	call	DWORD PTR __imp__CreateCompatibleDC@4

; 67   : 	if (!g_memDC) {

	xor	esi, esi
	cmp	eax, esi
	mov	DWORD PTR _g_memDC, eax

; 68   : 		return false;

	je	$LN4@CreateMain

; 69   : 	}
; 70   : 	BITMAPINFO info;
; 71   : 	info.bmiHeader.biSize = sizeof(info.bmiHeader);
; 72   : 	info.bmiHeader.biWidth			= tracer->GetImageWidth();

	mov	eax, DWORD PTR ?tracer@@3PAVTestTracer@@A ; tracer
	mov	DWORD PTR _info$[esp+56], 40		; 00000028H
	mov	ecx, DWORD PTR [eax+4]

; 73   : 	info.bmiHeader.biHeight			= -tracer->GetImageHeight();
; 74   : 	info.bmiHeader.biPlanes			= 1;
; 75   : 	info.bmiHeader.biBitCount		= 32;
; 76   : 	info.bmiHeader.biCompression	= BI_RGB;
; 77   : 	info.bmiHeader.biSizeImage		= 0;
; 78   : 	info.bmiHeader.biXPelsPerMeter	= 0;
; 79   : 	info.bmiHeader.biYPelsPerMeter	= 0;
; 80   : 	info.bmiHeader.biClrUsed		= 0;
; 81   : 	info.bmiHeader.biClrImportant	= 0;
; 82   : 
; 83   : 	Byte* image;
; 84   : 	g_bitmap = CreateDIBSection(GetDC(g_hWnd), &info, DIB_RGB_COLORS, (void**)&image, NULL, 0);

	push	esi
	mov	DWORD PTR _info$[esp+64], ecx
	mov	edx, DWORD PTR [eax+8]
	push	esi
	lea	eax, DWORD PTR _image$[esp+64]
	push	eax
	neg	edx
	push	esi
	lea	ecx, DWORD PTR _info$[esp+72]
	mov	DWORD PTR _info$[esp+80], edx
	mov	edx, DWORD PTR _g_hWnd
	push	ecx
	push	edx
	mov	WORD PTR _info$[esp+92], 1
	mov	WORD PTR _info$[esp+94], 32		; 00000020H
	mov	DWORD PTR _info$[esp+96], esi
	mov	DWORD PTR _info$[esp+100], esi
	mov	DWORD PTR _info$[esp+104], esi
	mov	DWORD PTR _info$[esp+108], esi
	mov	DWORD PTR _info$[esp+112], esi
	mov	DWORD PTR _info$[esp+116], esi
	call	edi
	push	eax
	call	DWORD PTR __imp__CreateDIBSection@24

; 85   : 	if (!g_bitmap) {

	cmp	eax, esi
	mov	DWORD PTR _g_bitmap, eax

; 86   : 		return false;

	je	SHORT $LN4@CreateMain

; 87   : 	}
; 88   : 	HGDIOBJ res = SelectObject(g_memDC, g_bitmap);

	push	eax
	mov	eax, DWORD PTR _g_memDC
	push	eax
	call	DWORD PTR __imp__SelectObject@8

; 89   : 	if (!res || res == HGDI_ERROR) {

	cmp	eax, esi
	je	SHORT $LN4@CreateMain
	cmp	eax, -1
	je	SHORT $LN4@CreateMain

; 91   : 	}
; 92   : 	BYTE* ptr = (BYTE*)image;
; 93   : 	for (int i = 3; i < tracer->GetImageWidth()*tracer->GetImageHeight()*4; i += 4) {

	mov	ecx, DWORD PTR ?tracer@@3PAVTestTracer@@A ; tracer
	mov	esi, DWORD PTR [ecx+4]
	imul	esi, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _image$[esp+56]
	add	esi, esi
	mov	eax, 3
	add	esi, esi
	cmp	esi, eax
	jle	SHORT $LN1@CreateMain
	npad	10
$LL3@CreateMain:

; 94   : 		ptr[i] = 255;

	mov	BYTE PTR [eax+edx], 255			; 000000ffH
	mov	esi, DWORD PTR [ecx+4]
	imul	esi, DWORD PTR [ecx+8]
	add	esi, esi
	add	eax, 4
	add	esi, esi
	cmp	eax, esi
	jl	SHORT $LL3@CreateMain
$LN1@CreateMain:

; 95   : 	}
; 96   : 
; 97   :   tracer->SetImage(image);

	mov	edx, DWORD PTR _image$[esp+56]
	pop	edi
	mov	DWORD PTR [ecx], edx

; 98   : 	return true;

	mov	al, 1
	pop	esi

; 99   : }

	add	esp, 48					; 00000030H
	ret	0
$LN4@CreateMain:
	pop	edi

; 90   : 		return false;

	xor	al, al
	pop	esi

; 99   : }

	add	esp, 48					; 00000030H
	ret	0
?CreateMainImage@@YA_NXZ ENDP				; CreateMainImage
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?CreateMainWindow@@YA_NH@Z
_TEXT	SEGMENT
_r$ = -64						; size = 16
_wcex$ = -48						; size = 48
_nCmdShow$ = 8						; size = 4
?CreateMainWindow@@YA_NH@Z PROC				; CreateMainWindow, COMDAT

; 29   : static bool CreateMainWindow(int nCmdShow) {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 68					; 00000044H

; 30   : 	// Register window class
; 31   : 	WNDCLASSEX wcex;
; 32   : 	wcex.cbSize = sizeof(WNDCLASSEX);
; 33   : 	wcex.style			= CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
; 34   : 	wcex.lpfnWndProc	= WndProc;
; 35   : 	wcex.cbClsExtra		= 0;
; 36   : 	wcex.cbWndExtra		= 0;
; 37   : 	wcex.hInstance		= g_hInstance;

	mov	eax, DWORD PTR _g_hInstance
	push	esi

; 38   : 	wcex.hIcon			= LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_RAYTRACER_APP));

	mov	esi, DWORD PTR __imp__LoadIconW@8
	push	107					; 0000006bH
	push	eax
	mov	DWORD PTR _wcex$[esp+80], 48		; 00000030H
	mov	DWORD PTR _wcex$[esp+84], 35		; 00000023H
	mov	DWORD PTR _wcex$[esp+88], OFFSET ?WndProc@@YGJPAUHWND__@@IIJ@Z ; WndProc
	mov	DWORD PTR _wcex$[esp+92], 0
	mov	DWORD PTR _wcex$[esp+96], 0
	mov	DWORD PTR _wcex$[esp+100], eax
	call	esi

; 39   : 	wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);

	push	32512					; 00007f00H
	push	0
	mov	DWORD PTR _wcex$[esp+104], eax
	call	DWORD PTR __imp__LoadCursorW@8
	mov	DWORD PTR _wcex$[esp+100], eax

; 40   : 	wcex.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1);
; 41   : 	wcex.lpszMenuName	= MAKEINTRESOURCE(IDC_RAYTRACER_APP);
; 42   : 	wcex.lpszClassName	= szWindowClass;
; 43   : 	wcex.hIconSm		= LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));

	mov	eax, DWORD PTR _wcex$[esp+92]
	push	108					; 0000006cH
	push	eax
	mov	DWORD PTR _wcex$[esp+112], 6
	mov	DWORD PTR _wcex$[esp+116], 109		; 0000006dH
	mov	DWORD PTR _wcex$[esp+120], OFFSET ??_C@_1CK@FDMHKDGK@?$AAR?$AAa?$AAy?$AAT?$AAr?$AAa?$AAc?$AAe?$AAr?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?$AA@
	call	esi

; 44   : 	if (!RegisterClassEx(&wcex)) {

	lea	ecx, DWORD PTR _wcex$[esp+72]
	push	ecx
	mov	DWORD PTR _wcex$[esp+120], eax
	call	DWORD PTR __imp__RegisterClassExW@4
	test	ax, ax
	jne	SHORT $LN2@CreateMain@2
$LN9@CreateMain@2:

; 45   : 		return false;

	xor	al, al

; 62   : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@CreateMain@2:

; 46   : 	}
; 47   : 	// Create window
; 48   : 	DWORD style = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX;
; 49   : 	RECT r;
; 50   : 	SetRect(&r, 0, 0, tracer->GetImageWidth()-1, tracer->GetImageHeight()-1);

	mov	eax, DWORD PTR ?tracer@@3PAVTestTracer@@A ; tracer
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+4]
	sub	edx, 1
	push	edx
	sub	eax, 1
	push	eax
	push	0
	push	0
	lea	ecx, DWORD PTR _r$[esp+88]
	push	ecx
	call	DWORD PTR __imp__SetRect@20

; 51   : 	BOOL res = AdjustWindowRect(&r, style, TRUE);

	push	1
	push	13238272				; 00ca0000H
	lea	edx, DWORD PTR _r$[esp+80]
	push	edx
	call	DWORD PTR __imp__AdjustWindowRect@12

; 52   : 	assert(res);
; 53   : 	const int w = r.right - r.left + 1;
; 54   : 	const int h = r.bottom - r.top + 1;
; 55   : 	g_hWnd = CreateWindow(szWindowClass, szTitle, style, CW_USEDEFAULT, 0, w, h, NULL, NULL, g_hInstance, NULL);

	mov	edx, DWORD PTR _g_hInstance
	mov	ecx, DWORD PTR _r$[esp+84]
	mov	eax, DWORD PTR _r$[esp+80]
	sub	ecx, DWORD PTR _r$[esp+76]
	sub	eax, DWORD PTR _r$[esp+72]
	push	0
	push	edx
	push	0
	push	0
	add	ecx, 1
	push	ecx
	add	eax, 1
	push	eax
	push	0
	push	-2147483648				; 80000000H
	push	13238272				; 00ca0000H
	push	OFFSET ??_C@_1CC@NIBKJCGP@?$AAR?$AAa?$AAy?$AA?5?$AAt?$AAr?$AAa?$AAc?$AAi?$AAn?$AAg?$AA?5?$AAt?$AAe?$AAs?$AAt?$AA?$AA@
	push	OFFSET ??_C@_1CK@FDMHKDGK@?$AAR?$AAa?$AAy?$AAT?$AAr?$AAa?$AAc?$AAe?$AAr?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?$AA@
	push	0
	call	DWORD PTR __imp__CreateWindowExW@48

; 56   : 	if (!g_hWnd) {

	test	eax, eax
	mov	DWORD PTR _g_hWnd, eax

; 57   : 		return false;

	je	$LN9@CreateMain@2

; 58   : 	}
; 59   : 	ShowWindow(g_hWnd, nCmdShow);

	mov	ecx, DWORD PTR _nCmdShow$[ebp]
	push	ecx
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 60   : 	UpdateWindow(g_hWnd);

	mov	edx, DWORD PTR _g_hWnd
	push	edx
	call	DWORD PTR __imp__UpdateWindow@4

; 61   : 	return true;

	mov	al, 1

; 62   : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?CreateMainWindow@@YA_NH@Z ENDP				; CreateMainWindow
_TEXT	ENDS
PUBLIC	?CreateRenderer@@YAXXZ				; CreateRenderer
; Function compile flags: /Ogtpy
;	COMDAT ?CreateRenderer@@YAXXZ
_TEXT	SEGMENT
?CreateRenderer@@YAXXZ PROC				; CreateRenderer, COMDAT

; 25   :   tracer = new TestTracer(IMAGE_WIDTH, IMAGE_HEIGHT);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@CreateRend
	mov	ecx, 400				; 00000190H
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR ?tracer@@3PAVTestTracer@@A, eax ; tracer

; 26   :   }

	ret	0
$LN3@CreateRend:

; 25   :   tracer = new TestTracer(IMAGE_WIDTH, IMAGE_HEIGHT);

	xor	eax, eax
	mov	DWORD PTR ?tracer@@3PAVTestTracer@@A, eax ; tracer

; 26   :   }

	ret	0
?CreateRenderer@@YAXXZ ENDP				; CreateRenderer
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2029 : 		if (!_Built)

	cmp	BYTE PTR __Built$[esp-4], 0
	push	esi
	push	edi
	mov	edi, DWORD PTR __Newsize$[esp+4]
	mov	esi, ecx
	je	SHORT $LN15@Tidy@2

; 2030 : 			;
; 2031 : 		else if (_BUF_SIZE <= _Myres)

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $LN15@Tidy@2

; 2032 : 			{	// copy any leftovers to small buffer and deallocate
; 2033 : 			_Elem *_Ptr = _Bx._Ptr;
; 2034 : 			if (0 < _Newsize)

	test	edi, edi
	lea	eax, DWORD PTR [esi+4]
	push	ebx
	mov	ebx, DWORD PTR [eax]
	jbe	SHORT $LN13@Tidy@2

; 2035 : 				_Traits_helper::copy_s<_Traits>(_Bx._Buf, _BUF_SIZE, _Ptr, _Newsize);

	push	edi
	push	ebx
	push	16					; 00000010H
	push	eax
	call	_memcpy_s
	add	esp, 16					; 00000010H
$LN13@Tidy@2:

; 2036 : 			_Mybase::_Alval.deallocate(_Ptr, _Myres + 1);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	ebx
$LN15@Tidy@2:

; 2037 : 			}
; 2038 : 		_Myres = _BUF_SIZE - 1;
; 2039 : 		_Eos(_Newsize);

	mov	DWORD PTR [esi+20], edi
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	BYTE PTR [esi+edi+4], 0
	pop	edi
	pop	esi

; 2040 : 		}

	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File d:\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$1
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$0
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$5
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\xstring
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT
$T34918 = -40						; size = 12
__Newres$ = -28						; size = 4
$T34904 = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ptr$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 1962 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi

; 1963 : 		size_type _Newres = _Newsize | _ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	esi, eax
	or	esi, 15					; 0000000fH

; 1964 : 		if (max_size() < _Newres)

	cmp	esi, -2					; fffffffeH
	jbe	SHORT $LN6@Copy

; 1965 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	esi, eax

; 1966 : 		else if (_Newres / 3 < _Myres / 2

	jmp	SHORT $LN4@Copy
$LN6@Copy:

; 1967 : 			&& _Myres <= max_size() - _Myres / 2)

	mov	ebx, DWORD PTR [edi+24]
	mov	eax, -1431655765			; aaaaaaabH
	mul	esi
	mov	ecx, ebx
	shr	ecx, 1
	shr	edx, 1
	cmp	edx, ecx
	jae	SHORT $LN4@Copy
	mov	eax, -2					; fffffffeH
	sub	eax, ecx
	cmp	ebx, eax
	ja	SHORT $LN4@Copy

; 1968 : 			_Newres = _Myres + _Myres / 2;	// grow exponentially if possible

	lea	esi, DWORD PTR [ecx+ebx]
$LN4@Copy:

; 1969 : 		_Elem *_Ptr = 0;
; 1970 : 
; 1971 : 		_TRY_BEGIN

	xor	ebx, ebx

; 1972 : 			_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

	lea	ecx, DWORD PTR [esi+1]
	cmp	ecx, ebx
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	ja	SHORT $LN37@Copy
	xor	ecx, ecx
$LN35@Copy:
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax

; 1980 : 			_CATCH_END
; 1981 : 		_CATCH_END

	jmp	SHORT $LN16@Copy

; 1972 : 			_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

$LN37@Copy:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 1
	jae	SHORT $LN35@Copy
	lea	ecx, DWORD PTR $T34904[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T34918[ebp]
	mov	DWORD PTR $T34904[ebp], ebx
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	edx, DWORD PTR $T34918[ebp]
	push	edx
	mov	DWORD PTR $T34918[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN116@Copy:
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$0:

; 1973 : 		_CATCH_ALL
; 1974 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	eax, DWORD PTR __Newsize$[ebp]

; 1975 : 			_TRY_BEGIN
; 1976 : 				_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR __Newres$[ebp], eax
	add	eax, 1
	mov	DWORD PTR __$EHRec$[ebp], esp
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 1980 : 			_CATCH_END
; 1981 : 		_CATCH_END

	mov	eax, $LN112@Copy
	ret	0
$LN112@Copy:
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR __Newres$[ebp]
$LN16@Copy:

; 1982 : 
; 1983 : 		if (0 < _Oldlen)

	mov	ebx, DWORD PTR __Oldlen$[ebp]
	test	ebx, ebx
	jbe	SHORT $LN78@Copy

; 1984 : 			_Traits_helper::copy_s<_Traits>(_Ptr, _Newres + 1, _Myptr(), _Oldlen);	// copy existing elements

	cmp	DWORD PTR [edi+24], 16			; 00000010H
	jb	SHORT $LN70@Copy
	mov	eax, DWORD PTR [edi+4]
	jmp	SHORT $LN71@Copy
$LN70@Copy:
	lea	eax, DWORD PTR [edi+4]
$LN71@Copy:
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ebx
	push	eax
	lea	eax, DWORD PTR [esi+1]
	push	eax
	push	ecx
	call	_memcpy_s
	add	esp, 16					; 00000010H
$LN78@Copy:

; 1985 : 		_Tidy(true);

	cmp	DWORD PTR [edi+24], 16			; 00000010H
	jb	SHORT $LN94@Copy
	mov	edx, DWORD PTR [edi+4]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN94@Copy:

; 1986 : 		_Bx._Ptr = _Ptr;
; 1987 : 		_Myres = _Newres;
; 1988 : 		_Eos(_Oldlen);

	cmp	esi, 16					; 00000010H
	mov	ecx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edi+4]
	mov	BYTE PTR [eax], 0
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [edi+24], esi
	mov	DWORD PTR [edi+20], ebx
	jb	SHORT $LN108@Copy
	mov	eax, ecx
$LN108@Copy:
	mov	BYTE PTR [eax+ebx], 0

; 1989 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$1:

; 1977 : 			_CATCH_ALL
; 1978 : 			_Tidy(true);	// failed again, discard storage and reraise

	mov	esi, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $LN58@Copy
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN58@Copy:

; 1979 : 			_RERAISE;

	push	0
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], 0
	push	0
	mov	BYTE PTR [esi+4], 0
	call	__CxxThrowException@8
$LN117@Copy:
$LN115@Copy:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Ogtpy
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 1998 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebx

; 1999 : 			if (max_size() < _Newsize)

	mov	ebx, DWORD PTR __Newsize$[esp]
	cmp	ebx, -2					; fffffffeH
	push	esi
	mov	esi, ecx
	jbe	SHORT $LN6@Grow

; 2000 : 			_String_base::_Xlen();	// result too long

	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN6@Grow:

; 2001 : 		if (_Myres < _Newsize)

	mov	eax, DWORD PTR [esi+24]
	cmp	eax, ebx
	jae	SHORT $LN5@Grow

; 2002 : 			_Copy(_Newsize, _Mysize);	// reallocate to grow

	mov	eax, DWORD PTR [esi+20]
	push	eax
	push	ebx
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2008 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	ecx, ecx
	cmp	ecx, ebx
	sbb	eax, eax
	pop	esi
	neg	eax
	pop	ebx

; 2009 : 		}

	ret	8
$LN5@Grow:

; 2003 : 		else if (_Trim && _Newsize < _BUF_SIZE)

	cmp	BYTE PTR __Trim$[esp+4], 0
	je	SHORT $LN3@Grow
	cmp	ebx, 16					; 00000010H
	jae	SHORT $LN3@Grow
	push	edi

; 2004 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2005 : 				_Newsize < _Mysize ? _Newsize : _Mysize);

	mov	edi, DWORD PTR [esi+20]
	cmp	ebx, edi
	jae	SHORT $LN9@Grow
	mov	edi, ebx
$LN9@Grow:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN33@Grow
	test	edi, edi
	lea	eax, DWORD PTR [esi+4]
	push	ebp
	mov	ebp, DWORD PTR [eax]
	jbe	SHORT $LN31@Grow
	push	edi
	push	ebp
	push	16					; 00000010H
	push	eax
	call	_memcpy_s
	add	esp, 16					; 00000010H
$LN31@Grow:
	push	ebp
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	ebp
$LN33@Grow:
	mov	DWORD PTR [esi+20], edi
	mov	DWORD PTR [esi+24], 15			; 0000000fH

; 2008 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	ecx, ecx
	mov	BYTE PTR [esi+edi+4], 0
	cmp	ecx, ebx
	pop	edi
	sbb	eax, eax
	pop	esi
	neg	eax
	pop	ebx

; 2009 : 		}

	ret	8
$LN3@Grow:

; 2006 : 		else if (_Newsize == 0)

	test	ebx, ebx
	jne	SHORT $LN49@Grow

; 2007 : 			_Eos(0);	// new size is zero, just null terminate

	cmp	eax, 16					; 00000010H
	mov	DWORD PTR [esi+20], ebx
	jb	SHORT $LN47@Grow
	mov	esi, DWORD PTR [esi+4]

; 2008 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	ecx, ecx
	cmp	ecx, ebx
	mov	BYTE PTR [esi], bl
	sbb	eax, eax
	pop	esi
	neg	eax
	pop	ebx

; 2009 : 		}

	ret	8

; 2007 : 			_Eos(0);	// new size is zero, just null terminate

$LN47@Grow:
	add	esi, 4
	mov	BYTE PTR [esi], 0
$LN49@Grow:

; 2008 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	ecx, ecx
	cmp	ecx, ebx
	sbb	eax, eax
	pop	esi
	neg	eax
	pop	ebx

; 2009 : 		}

	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
PUBLIC	_wWinMain@16
; Function compile flags: /Ogtpy
; File d:\development\source\raytracer\testtrace\raytracer_app.cpp
;	COMDAT _wWinMain@16
_TEXT	SEGMENT
_msg$ = -28						; size = 28
_hInstance$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
_nCmdShow$ = 20						; size = 4
_wWinMain@16 PROC					; COMDAT

; 116  : 	g_hInstance = hInstance;

	mov	eax, DWORD PTR _hInstance$[esp-4]
	sub	esp, 28					; 0000001cH

; 117  :   CreateRenderer();

	push	12					; 0000000cH
	mov	DWORD PTR _g_hInstance, eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@wWinMain
	mov	ecx, 400				; 00000190H
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN14@wWinMain
$LN13@wWinMain:
	xor	eax, eax
$LN14@wWinMain:

; 118  : 	if (!CreateMainWindow(nCmdShow)) {

	mov	ecx, DWORD PTR _nCmdShow$[esp+24]
	push	ecx
	mov	DWORD PTR ?tracer@@3PAVTestTracer@@A, eax ; tracer
	call	?CreateMainWindow@@YA_NH@Z		; CreateMainWindow
	add	esp, 4
	test	al, al

; 119  : 		return FALSE;

	je	$LN29@wWinMain

; 120  : 	}
; 121  : 	if (!CreateMainImage()) {

	call	?CreateMainImage@@YA_NXZ		; CreateMainImage
	test	al, al

; 122  : 		return FALSE;

	je	$LN29@wWinMain
	push	ebx
	mov	ebx, DWORD PTR __imp__GetDC@4
	push	ebp
	mov	ebp, DWORD PTR __imp__DispatchMessageW@4
	push	esi
	mov	esi, DWORD PTR __imp__PeekMessageW@20
	push	edi
	mov	edi, DWORD PTR __imp__BitBlt@36
	npad	4
$LL6@wWinMain:

; 123  : 	}
; 124  : 	
; 125  : 	MSG msg;
; 126  : 	while (true) {
; 127  : 		// Process messages
; 128  : 		while (PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE)) {

	push	0
	push	0
	push	0
	push	0
	lea	edx, DWORD PTR _msg$[esp+60]
	push	edx
	call	esi
	test	eax, eax
	je	SHORT $LN3@wWinMain
$LL4@wWinMain:

; 129  : 			if (GetMessage(&msg, NULL, 0, 0)) {

	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _msg$[esp+56]
	push	eax
	call	DWORD PTR __imp__GetMessageW@16
	test	eax, eax
	je	SHORT $LN2@wWinMain

; 130  : 				DispatchMessage(&msg);

	lea	ecx, DWORD PTR _msg$[esp+44]
	push	ecx
	call	ebp
	push	0
	push	0
	push	0
	push	0
	lea	edx, DWORD PTR _msg$[esp+60]
	push	edx
	call	esi
	test	eax, eax
	jne	SHORT $LL4@wWinMain
$LN3@wWinMain:

; 134  : 			}
; 135  : 		}
; 136  : 		tracer->RenderImage();
; 137  : 		BitBlt(GetDC(g_hWnd), 0, 0, tracer->GetImageWidth(), tracer->GetImageHeight(), g_memDC, 0, 0, SRCCOPY);

	mov	eax, DWORD PTR ?tracer@@3PAVTestTracer@@A ; tracer
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _g_memDC
	mov	eax, DWORD PTR [eax+4]
	push	13369376				; 00cc0020H
	push	0
	push	0
	push	edx
	push	ecx
	push	eax
	mov	eax, DWORD PTR _g_hWnd
	push	0
	push	0
	push	eax
	call	ebx
	push	eax
	call	edi

; 138  : 	}

	jmp	SHORT $LL6@wWinMain
$LN2@wWinMain:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN29@wWinMain:

; 131  : 			}
; 132  : 			else {
; 133  : 				return 0;

	xor	eax, eax

; 139  : 	DeleteDC(g_memDC);
; 140  : 	DeleteObject(g_bitmap);
; 141  : 	return (int) msg.wParam;
; 142  : }

	add	esp, 28					; 0000001cH
	ret	16					; 00000010H
_wWinMain@16 ENDP
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\xstring
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 866  : 		{	// destroy the string

	push	esi
	mov	esi, ecx

; 867  : 		_Tidy(true);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $LN17@basic_stri
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@basic_stri:
	xor	eax, eax
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], eax
	mov	BYTE PTR [esi+4], al
	pop	esi

; 868  : 		}

	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\stdexcept
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 31   : 		{	// destroy the object

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@

; 32   : 		}

	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $LN19@logic_erro
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN19@logic_erro:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	BYTE PTR [esi+16], al
	mov	ecx, esi
	pop	esi
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $LN22@scalar@2
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN22@scalar@2:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	ecx, esi
	mov	BYTE PTR [esi+16], al
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN32@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1000 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebx

; 1001 : 		if (_Right.size() < _Roff)

	mov	ebx, DWORD PTR __Right$[esp]
	push	ebp
	mov	ebp, DWORD PTR __Roff$[esp+4]
	cmp	DWORD PTR [ebx+20], ebp
	push	esi
	push	edi
	mov	esi, ecx
	jae	SHORT $LN5@assign

; 1002 : 			_String_base::_Xran();	// _Roff off end

	call	?_Xran@_String_base@std@@SAXXZ		; std::_String_base::_Xran
$LN5@assign:

; 1003 : 		size_type _Num = _Right.size() - _Roff;

	mov	edi, DWORD PTR [ebx+20]

; 1004 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[esp+12]
	sub	edi, ebp
	cmp	eax, edi
	jae	SHORT $LN4@assign

; 1005 : 			_Num = _Count;	// trim _Num to size

	mov	edi, eax
$LN4@assign:

; 1006 : 
; 1007 : 		if (this == &_Right)

	cmp	esi, ebx
	jne	SHORT $LN3@assign

; 1008 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	push	-1
	add	edi, ebp
	push	edi
	mov	ecx, esi
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	push	ebp
	push	0
	mov	ecx, esi
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 1013 : 			}
; 1014 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1015 : 		}

	ret	12					; 0000000cH
$LN3@assign:

; 1009 : 		else if (_Grow(_Num))

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN17@assign
	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN17@assign:
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, edi
	jae	SHORT $LN16@assign
	mov	eax, DWORD PTR [esi+20]
	push	eax
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	edi, edi
$LN87@assign:
	jbe	SHORT $LN86@assign

; 1010 : 			{	// make room and assign new stuff
; 1011 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Right._Myptr() + _Roff, _Num);

	cmp	DWORD PTR [ebx+24], 16			; 00000010H
	jb	SHORT $LN64@assign
	mov	edx, DWORD PTR [ebx+4]
	jmp	SHORT $LN65@assign

; 1009 : 		else if (_Grow(_Num))

$LN16@assign:
	test	edi, edi
	jne	SHORT $LN87@assign
	cmp	eax, 16					; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN58@assign
	mov	eax, DWORD PTR [esi+4]
	pop	edi
	mov	BYTE PTR [eax], 0

; 1013 : 			}
; 1014 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1015 : 		}

	ret	12					; 0000000cH

; 1009 : 		else if (_Grow(_Num))

$LN58@assign:
	lea	eax, DWORD PTR [esi+4]
	pop	edi
	mov	BYTE PTR [eax], 0

; 1013 : 			}
; 1014 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1015 : 		}

	ret	12					; 0000000cH

; 1010 : 			{	// make room and assign new stuff
; 1011 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Right._Myptr() + _Roff, _Num);

$LN64@assign:
	lea	edx, DWORD PTR [ebx+4]
$LN65@assign:
	mov	ecx, DWORD PTR [esi+24]
	cmp	ecx, 16					; 00000010H
	lea	ebx, DWORD PTR [esi+4]
	jb	SHORT $LN68@assign
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN69@assign
$LN68@assign:
	mov	eax, ebx
$LN69@assign:
	push	edi
	add	edx, ebp
	push	edx
	push	ecx
	push	eax
	call	_memcpy_s
	add	esp, 16					; 00000010H

; 1012 : 			_Eos(_Num);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN82@assign
	mov	ebx, DWORD PTR [ebx]
$LN82@assign:
	mov	BYTE PTR [ebx+edi], 0
$LN86@assign:
	pop	edi

; 1013 : 			}
; 1014 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1015 : 		}

	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Num$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1018 : 		{	// assign [_Ptr, _Ptr + _Num)

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 1019 : 		if (_Inside(_Ptr))

	mov	ecx, DWORD PTR [esi+24]
	cmp	ecx, 16					; 00000010H
	lea	ebx, DWORD PTR [esi+4]
	jb	SHORT $LN12@assign@2
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN13@assign@2
$LN12@assign@2:
	mov	eax, ebx
$LN13@assign@2:
	mov	ebp, DWORD PTR __Ptr$[esp+8]
	cmp	ebp, eax
	jb	SHORT $LN2@assign@2
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN16@assign@2
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN17@assign@2
$LN16@assign@2:
	mov	eax, ebx
$LN17@assign@2:
	mov	edx, DWORD PTR [esi+20]
	add	edx, eax
	cmp	edx, ebp
	jbe	SHORT $LN2@assign@2

; 1020 : 			return (assign(*this, _Ptr - _Myptr(), _Num));	// substring

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN20@assign@2
	mov	ebx, DWORD PTR [ebx]
$LN20@assign@2:
	mov	eax, DWORD PTR __Num$[esp+8]
	push	eax
	sub	ebp, ebx
	push	ebp
	push	esi
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi
	pop	ebp
	pop	ebx

; 1028 : 		}

	ret	8
$LN2@assign@2:
	push	edi

; 1021 : 
; 1022 : 		if (_Grow(_Num))

	mov	edi, DWORD PTR __Num$[esp+12]
	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN27@assign@2
	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN27@assign@2:
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, edi
	jae	SHORT $LN26@assign@2
	mov	ecx, DWORD PTR [esi+20]
	push	ecx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	edi, edi
$LN93@assign@2:
	jbe	SHORT $LN90@assign@2

; 1023 : 			{	// make room and assign new stuff
; 1024 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Ptr, _Num);

	mov	ecx, DWORD PTR [esi+24]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN74@assign@2
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN75@assign@2

; 1021 : 
; 1022 : 		if (_Grow(_Num))

$LN26@assign@2:
	test	edi, edi
	jne	SHORT $LN93@assign@2
	cmp	eax, 16					; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN68@assign@2
	mov	ebx, DWORD PTR [ebx]
$LN68@assign@2:
	pop	edi

; 1026 : 			}
; 1027 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	mov	BYTE PTR [ebx], 0
	pop	ebx

; 1028 : 		}

	ret	8

; 1023 : 			{	// make room and assign new stuff
; 1024 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Ptr, _Num);

$LN74@assign@2:
	mov	eax, ebx
$LN75@assign@2:
	push	edi
	push	ebp
	push	ecx
	push	eax
	call	_memcpy_s
	add	esp, 16					; 00000010H

; 1025 : 			_Eos(_Num);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN88@assign@2
	mov	ebx, DWORD PTR [ebx]
$LN88@assign@2:
	mov	BYTE PTR [ebx+edi], 0
$LN90@assign@2:
	pop	edi

; 1026 : 			}
; 1027 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1028 : 		}

	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1031 : 		{	// assign [_Ptr, <null>)

	push	esi

; 1032 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	esi, DWORD PTR __Ptr$[esp]
	mov	eax, esi
	push	edi
	lea	edi, DWORD PTR [eax+1]
	npad	5
$LL5@assign@3:
	mov	dl, BYTE PTR [eax]
	add	eax, 1
	test	dl, dl
	jne	SHORT $LL5@assign@3
	sub	eax, edi
	push	eax
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	pop	esi

; 1033 : 		}

	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 632  : 		_Tidy();
; 633  : 		assign(_Ptr);

	mov	edx, DWORD PTR __Ptr$[esp-4]
	push	esi
	mov	esi, ecx
	mov	eax, edx
	push	edi
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], 0
	mov	BYTE PTR [esi+4], 0
	lea	edi, DWORD PTR [eax+1]
	npad	1
$LL37@basic_stri@2:
	mov	cl, BYTE PTR [eax]
	add	eax, 1
	test	cl, cl
	jne	SHORT $LL37@basic_stri@2
	sub	eax, edi
	push	eax
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi

; 634  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\stdexcept
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 110  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 111  : 		}

	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $LN21@length_err
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN21@length_err:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	BYTE PTR [esi+16], al
	mov	ecx, esi
	pop	esi
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $LN24@scalar@3
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@scalar@3:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	ecx, esi
	mov	BYTE PTR [esi+16], al
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN34@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN34@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\xstring
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 594  : 		{	// construct by copying _Right

	push	esi

; 595  : 		_Tidy();

	xor	eax, eax
	mov	esi, ecx

; 596  : 		assign(_Right, 0, npos);

	push	-1
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	push	eax
	mov	BYTE PTR [esi+4], al
	mov	eax, DWORD PTR __Right$[esp+8]
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 597  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+28], esi
	mov	edi, DWORD PTR ___that$[esp+24]
	push	edi
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[esp+36], eax
	push	-1
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	push	eax
	add	edi, 12					; 0000000cH
	mov	DWORD PTR [ecx+24], 15			; 0000000fH
	mov	DWORD PTR [ecx+20], eax
	push	edi
	mov	BYTE PTR [ecx+4], al
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Ogtpy
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\stdexcept
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 27   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi
	call	??0exception@std@@QAE@XZ		; std::exception::exception
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[esp+32], eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	push	-1
	mov	DWORD PTR [ecx+20], eax
	mov	DWORD PTR [ecx+24], 15			; 0000000fH
	push	eax
	mov	BYTE PTR [ecx+4], al
	mov	eax, DWORD PTR __Message$[esp+28]
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 28   : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
; Function compile flags: /Ogtpy
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 106  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 107  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File d:\microsoft visual studio 8\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T37033 = -84						; size = 28
$T37032 = -56						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ PROC	; std::vector<float,std::allocator<float> >::_Xlen, COMDAT

; 1213 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+92]
	mov	DWORD PTR fs:0, eax

; 1214 : 		_THROW(length_error, "vector<T> too long");

	push	18					; 00000012H
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T37033[esp+100]
	mov	DWORD PTR $T37033[esp+124], 15		; 0000000fH
	mov	DWORD PTR $T37033[esp+120], 0
	mov	BYTE PTR $T37033[esp+104], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T37033[esp+92]
	push	eax
	lea	ecx, DWORD PTR $T37032[esp+96]
	mov	DWORD PTR __$EHRec$[esp+104], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T37032[esp+96]
	push	ecx
	mov	DWORD PTR $T37032[esp+100], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN45@Xlen:
$LN44@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T37033[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-76]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ ENDP	; std::vector<float,std::allocator<float> >::_Xlen
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@MV?$allocator@M@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
$T37218 = -16						; size = 4
$T37232 = -12						; size = 12
?_Buy@?$vector@MV?$allocator@M@std@@@std@@IAE_NI@Z PROC	; std::vector<float,std::allocator<float> >::_Buy, COMDAT
; __Capacity$ = esi

; 1066 : 		{	// allocate array with _Capacity elements

	sub	esp, 16					; 00000010H

; 1067 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 1068 : 		if (_Capacity == 0)
; 1069 : 			return (false);
; 1070 : 		else if (max_size() < _Capacity)

	cmp	esi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy

; 1071 : 			_Xlen();	// result too long

	jmp	?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ ; std::vector<float,std::allocator<float> >::_Xlen
$LN2@Buy:

; 1072 : 		else
; 1073 : 			{	// nonempty array, allocate storage
; 1074 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	test	esi, esi
	mov	ecx, esi
	ja	SHORT $LN21@Buy
	xor	ecx, ecx
$LN19@Buy:
	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	mov	DWORD PTR _g_fpsValues+4, eax

; 1075 : 			_Mylast = _Myfirst;

	mov	DWORD PTR _g_fpsValues+8, eax

; 1076 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR _g_fpsValues+12, eax
	add	esp, 4

; 1077 : 			}
; 1078 : 		return (true);

	mov	al, 1

; 1079 : 		}

	add	esp, 16					; 00000010H
	ret	0

; 1072 : 		else
; 1073 : 			{	// nonempty array, allocate storage
; 1074 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN21@Buy:
	or	eax, -1
	xor	edx, edx
	div	esi
	cmp	eax, 4
	jae	SHORT $LN19@Buy
	lea	eax, DWORD PTR $T37218[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T37232[esp+20]
	mov	DWORD PTR $T37218[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T37232[esp+20]
	push	ecx
	mov	DWORD PTR $T37232[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN29@Buy:
$LN28@Buy:
	int	3
?_Buy@?$vector@MV?$allocator@M@std@@@std@@IAE_NI@Z ENDP	; std::vector<float,std::allocator<float> >::_Buy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ PROC	; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >, COMDAT

; 458  : 		_Buy(0);

	xor	eax, eax
	mov	DWORD PTR _g_fpsValues+4, eax
	mov	DWORD PTR _g_fpsValues+8, eax
	mov	DWORD PTR _g_fpsValues+12, eax

; 459  : 		}

	mov	eax, OFFSET _g_fpsValues
	ret	0
??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ENDP	; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
; Function compile flags: /Ogtpy
; File d:\development\source\raytracer\testtrace\raytracer_app.cpp
_TEXT	ENDS
;	COMDAT ??__Eg_fpsValues@@YAXXZ
text$yc	SEGMENT
??__Eg_fpsValues@@YAXXZ PROC				; `dynamic initializer for 'g_fpsValues'', COMDAT

; 104  : static std::vector<float> g_fpsValues;

	push	OFFSET ??__Fg_fpsValues@@YAXXZ		; `dynamic atexit destructor for 'g_fpsValues''
	call	_atexit
	pop	ecx
	ret	0
??__Eg_fpsValues@@YAXXZ ENDP				; `dynamic initializer for 'g_fpsValues''
; Function compile flags: /Ogtpy
text$yc	ENDS
;	COMDAT ??__Fg_fpsValues@@YAXXZ
text$yd	SEGMENT
??__Fg_fpsValues@@YAXXZ PROC				; `dynamic atexit destructor for 'g_fpsValues'', COMDAT
	mov	eax, DWORD PTR _g_fpsValues+4
	test	eax, eax
	je	SHORT $LN8@dynamic
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@dynamic:
	mov	DWORD PTR _g_fpsValues+4, 0
	mov	DWORD PTR _g_fpsValues+8, 0
	mov	DWORD PTR _g_fpsValues+12, 0
	ret	0
??__Fg_fpsValues@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_fpsValues''
_g_fpsValues DB	010H DUP (?)
CRT$XCU	SEGMENT
_g_fpsValues$initializer$ DD FLAT:??__Eg_fpsValues@@YAXXZ
CRT$XCU	ENDS
END
