#include "SamplerBasedRenderer.h"
#include <Common/Numerics.h>
#include <Math/Constants.h>
#include <tbb/pipeline.h>
#include <vector>

/////////////////////////////////////////// Internal Types ////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
* This is a DTO class used to store samples and resulting radiance values returned by a renderer.
* The class is passed through the TBB pipeline by SamplesGeneratorFilter, IntegratorFilter and FilmWriterFilter.
* The class also keeps MemoryPool instance used by integrators.
* Since the class is used by multiple threads it has a simple locking mechanism implemented by Acquire(), Release() and IsAvailable() methods.
* Although this locking strategy is not really thread-safe it works well for SamplesGeneratorFilter because this filter is serial and multiple
* threads will never race to acquire the lock over the chunk.
* @sa SamplesGeneratorFilter, IntegratorFilter and FilmWriterFilter
*/
class SamplerBasedRenderer::SamplesChunk
  {
  public:
    /**
    * Creates SamplesChunk instance.
    * @param ip_sampler Sampler instance used to create Samples.
    * @param i_max_samples_num Number of samples in the chunk. Should be positive.
    */
    SamplesChunk(intrusive_ptr<Sampler> ip_sampler, size_t i_max_samples_num);

    ~SamplesChunk();

    /**
    * Locks the chunk in a multi-threaded environment. The other threads will check if the chunk is available before locking it.
    */
    void Acquire();

    /**
    * Releases the chunk so the other threads can acquire it.
    */
    void Release();

    /**
    * Returns true if the chunk is not locked by any thread.
    */
    bool IsAvailable() const;

    /**
    * Fills the chunk samples with the data by calling the sampler.
    * @return true if at least one sample is filled with a data.
    */
    bool GenerateSamples();

    /**
    * Returns number of chunk samples filled with the data.
    * The returned value can be less than the maximum number of samples passed to the class constructor if the sampler did not generate enough samples.
    */
    size_t GetNumberOfSamples() const;

    /**
    * Returns (weak) pointer to the specified sample.
    * @param i_sample_index Index of the requested sample. Should be less than the value returned by GetNumberOfSamples() method.
    * @return Pointer to the sample.
    */
    const Sample *GetSample(size_t i_sample_index) const;

    /**
    * Sets resulting radiance for the specified camera sample index.
    * @param i_sample_index Index of the sample. Should be less than the value returned by GetNumberOfSamples() method.
    * @param i_radiance Radiance value.
    */
    void SetRadiance(size_t i_sample_index, const Spectrum_d &i_radiance);

    /**
    * Returns radiance saved for the specified camera index.
    */
    Spectrum_d GetRadiance(size_t i_sample_index) const;

    /**
    * Returns memory pool.
    */
    MemoryPool *GetMemoryPool() const;

  private:
    // Not implemented, should only be passed by a reference.
    SamplesChunk(const SamplesChunk&);
    SamplesChunk &operator=(const SamplesChunk&);

  private:
    intrusive_ptr<Sampler> mp_sampler;
    size_t m_samples_num;
    bool m_available;

    std::vector<intrusive_ptr<Sample> > m_samples;
    std::vector<Spectrum_d> m_radiances;

    MemoryPool *mp_memory_pool;
  };

/**
* This is the input filter for the TBB pipeline.
* It picks up an arbitrary available chunk, locks it to prevent other threads using it, fills it with the data from the sampler and returns.
* The filter is serial which means that two threads never execute it concurrently.
*/
class SamplerBasedRenderer::SamplesGeneratorFilter: public tbb::filter
  {
  public:
    SamplesGeneratorFilter(intrusive_ptr<Sampler> ip_sampler, size_t i_number_of_chunks, size_t i_samples_per_chunk);

    ~SamplesGeneratorFilter();

    void* operator()(void*);

  private:
    intrusive_ptr<Sampler> mp_sampler;

    std::vector<SamplesChunk*> m_chunks;

    size_t m_next_chunk_index;
  };

/**
* This is the processing filter for the TBB pipeline.
* The filter gets the chunk with the samples data generated by SamplesGeneratorFilter filter and computes radiance value for each camera sample.
* The filter is parallel which means that it can be executed by multiple threads concurrently.
*/
class SamplerBasedRenderer::IntegratorFilter: public tbb::filter
  {
  public:
    IntegratorFilter(const SamplerBasedRenderer *ip_renderer, intrusive_ptr<Camera> ip_camera, intrusive_ptr<Log> ip_log);

    void* operator()(void* ip_chunk);

  private:
    const SamplerBasedRenderer *mp_renderer;

    intrusive_ptr<Camera> mp_camera;
    intrusive_ptr<Log> mp_log;
  };

/**
* This is the output filter for the TBB pipeline.
* The filter gets the chunk with the samples data generated by SamplesGeneratorFilter filter and computed radiance values generated by IntegratorFilter filter
* and adds them to the camera's film.
* The filter is serial which means that two threads never execute it concurrently.
*/
class SamplerBasedRenderer::FilmWriterFilter: public tbb::filter
  {
  public:
    FilmWriterFilter(intrusive_ptr<Film> ip_film);

    void* operator()(void* ip_chunk);
  private:

    intrusive_ptr<Film> mp_film;
  };


//////////////////////////////////////// SamplerBasedRenderer /////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////

SamplerBasedRenderer::SamplerBasedRenderer(intrusive_ptr<Scene> ip_scene, intrusive_ptr<Sampler> ip_sampler, intrusive_ptr<Log> ip_log): Renderer(ip_scene),
mp_scene(ip_scene), mp_sampler(ip_sampler), mp_log(ip_log), mp_surface_integrator(NULL), mp_volume_integrator(NULL)
  {
  ASSERT(ip_scene);
  ASSERT(ip_sampler);
  }

void SamplerBasedRenderer::SetSurfaceIntegrator(intrusive_ptr<SurfaceIntegrator> ip_surface_integrator)
  {
  mp_surface_integrator=ip_surface_integrator;
  }

void SamplerBasedRenderer::SetVolumeIntegrator(intrusive_ptr<VolumeIntegrator> ip_volume_integrator)
  {
  mp_volume_integrator=ip_volume_integrator;
  }

Spectrum_d SamplerBasedRenderer::Radiance(const RayDifferential &i_ray, const Sample *ip_sample, MemoryPool &i_pool) const
  {
  ASSERT(mp_surface_integrator);
  ASSERT(i_ray.m_base_ray.m_direction.IsNormalized());

  Intersection isect;
  double intersection_t;
  bool hit=mp_scene->Intersect(i_ray, isect, &intersection_t);

  RayDifferential intersection_ray(i_ray);
  Spectrum_d radiance;
  if (hit)
    {
    radiance = mp_surface_integrator->Radiance(i_ray, isect, ip_sample, i_pool);
    intersection_ray.m_base_ray.m_max_t=intersection_t;
    }
  else
    if (IsInf(i_ray.m_base_ray.m_max_t)) // Check if the ray is unbounded.
      {
      // Add contribution of infinite light sources for an unbounded ray that does not intersect any primitive.
      const LightSources &lights = mp_scene->GetLightSources();
      for (size_t i = 0; i < lights.m_infinitiy_light_sources.size(); ++i)
        radiance += lights.m_infinitiy_light_sources[i]->Radiance(i_ray);
      }

  if (mp_volume_integrator)
    {
    Spectrum_d volume_radiance(0.0);
    Spectrum_d transmittance(1.0);

    volume_radiance = mp_volume_integrator->Radiance(intersection_ray, ip_sample, transmittance);
    ASSERT(InRange(transmittance, 0.0, 1.0));

    return radiance * transmittance + volume_radiance;
    }
  else
    return radiance;
  }

Spectrum_d SamplerBasedRenderer::Transmittance(const Ray &i_ray, const Sample *ip_sample) const
  {
  ASSERT(i_ray.m_direction.IsNormalized());

  if (mp_volume_integrator)
    {
    Spectrum_d transmittance = mp_volume_integrator->Transmittance(i_ray, ip_sample);
    ASSERT(InRange(transmittance, 0.0, 1.0));
    return transmittance;
    }
  else
    return Spectrum_d(1.0);
  }

void SamplerBasedRenderer::Render(intrusive_ptr<Camera> ip_camera) const
  {
  ASSERT(ip_camera);
  ASSERT(mp_surface_integrator);

  ip_camera->GetFilm()->ClearFilm();

  mp_sampler->Reset();
  mp_sampler->ClearSamplesSequences();

  mp_surface_integrator->RequestSamples(mp_sampler);
  if (mp_volume_integrator)
    mp_volume_integrator->RequestSamples(mp_sampler);

  /*
  Not sure what is the best strategy to choose the pipeline tokens number and the number of samples per chunk.
  I could not find a method in the TBB to find out how many threads the pipeline will be running.
  Currently, these values are hardcoded as MAX_PIPELINE_TOKENS_NUM and SAMPLES_PER_CHUNK constants.
  */
  SamplesGeneratorFilter samples_generator(mp_sampler, MAX_PIPELINE_TOKENS_NUM, SAMPLES_PER_CHUNK);
  IntegratorFilter integrator(this, ip_camera, mp_log);
  FilmWriterFilter film_writer(ip_camera->GetFilm());

  tbb::pipeline pipeline;
  pipeline.add_filter(samples_generator);
  pipeline.add_filter(integrator);
  pipeline.add_filter(film_writer);

  pipeline.run(MAX_PIPELINE_TOKENS_NUM);

  pipeline.clear();
  }

//////////////////////////////////////////// SamplesChunk /////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////

SamplerBasedRenderer::SamplesChunk::SamplesChunk(intrusive_ptr<Sampler> ip_sampler, size_t i_max_samples_num):
mp_sampler(ip_sampler), m_samples(i_max_samples_num), m_radiances(i_max_samples_num),
m_samples_num(0), m_available(true)
  {
  ASSERT(ip_sampler);
  ASSERT(i_max_samples_num>0);

  mp_memory_pool = new MemoryPool();

  for(size_t i=0;i<m_samples.size();++i)
    m_samples[i]=ip_sampler->CreateSample();
  }

SamplerBasedRenderer::SamplesChunk::~SamplesChunk()
  {
  delete mp_memory_pool;
  }

void SamplerBasedRenderer::SamplesChunk::Acquire()
  {
  ASSERT(m_available);
  m_available = false;
  }

void SamplerBasedRenderer::SamplesChunk::Release()
  {
  ASSERT(m_available==false);
  m_available = true;
  }

bool SamplerBasedRenderer::SamplesChunk::IsAvailable() const
  {
  return m_available;
  }

bool SamplerBasedRenderer::SamplesChunk::GenerateSamples()
  {
  m_samples_num = 0;
  for(size_t i=0;i<m_samples.size();++i)
    {
    if (mp_sampler->GetNextSample(m_samples[i]))
      ++m_samples_num;
    else
      break;
    }

  return m_samples_num > 0;
  }

size_t SamplerBasedRenderer::SamplesChunk::GetNumberOfSamples() const
  {
  ASSERT(m_samples_num <= m_samples.size());
  return m_samples_num;
  }

const Sample *SamplerBasedRenderer::SamplesChunk::GetSample(size_t i_sample_index) const
  {
  ASSERT(i_sample_index < m_samples_num);
  return m_samples[i_sample_index].get();
  }

void SamplerBasedRenderer::SamplesChunk::SetRadiance(size_t i_sample_index, const Spectrum_d &i_radiance)
  {
  ASSERT(i_sample_index < m_samples_num);
  m_radiances[i_sample_index] = i_radiance;
  }

Spectrum_d SamplerBasedRenderer::SamplesChunk::GetRadiance(size_t i_sample_index) const
  {
  ASSERT(i_sample_index < m_samples_num);
  return m_radiances[i_sample_index];
  }

MemoryPool *SamplerBasedRenderer::SamplesChunk::GetMemoryPool() const
  {
  return mp_memory_pool;
  }

/////////////////////////////////////// SamplesGeneratorFilter ////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////

SamplerBasedRenderer::SamplesGeneratorFilter::SamplesGeneratorFilter(intrusive_ptr<Sampler> ip_sampler, size_t i_number_of_chunks, size_t i_samples_per_chunk):
filter(serial_out_of_order), mp_sampler(ip_sampler), m_next_chunk_index(0)
  {
  ASSERT(ip_sampler);
  ASSERT(i_number_of_chunks>0);
  ASSERT(i_samples_per_chunk>0);

  for(size_t i=0;i<i_number_of_chunks;++i)
    m_chunks.push_back(new SamplesChunk(ip_sampler, i_samples_per_chunk));
  }

SamplerBasedRenderer::SamplesGeneratorFilter::~SamplesGeneratorFilter()
  {
  for(size_t i=0;i<m_chunks.size();++i)
    delete m_chunks[i];
  }

void* SamplerBasedRenderer::SamplesGeneratorFilter::operator()(void*)
  {
  /*
  Here we loop over all chunks until we find an available one, i.e. a one that is not locked by other thread.
  Although this is not really a thread-safe strategy it works well here since SamplesGeneratorFilter is serial, so two
  threads will never try to get a lock concurrently.
  */
  while(m_chunks[m_next_chunk_index]->IsAvailable()==false)
    m_next_chunk_index = (m_next_chunk_index+1) % m_chunks.size();

  SamplesChunk *p_chunk = m_chunks[m_next_chunk_index];
  p_chunk->Acquire();

  m_next_chunk_index = (m_next_chunk_index+1) % m_chunks.size();

  if (p_chunk->GenerateSamples())
    return p_chunk;
  else
    return NULL;
  }

////////////////////////////////////////// IntegratorFilter ///////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////

SamplerBasedRenderer::IntegratorFilter::IntegratorFilter(const SamplerBasedRenderer *ip_renderer, intrusive_ptr<Camera> ip_camera, intrusive_ptr<Log> ip_log): tbb::filter(parallel),
mp_renderer(ip_renderer), mp_camera(ip_camera), mp_log(ip_log)
  {
  ASSERT(ip_renderer);
  ASSERT(ip_camera);
  }

void* SamplerBasedRenderer::IntegratorFilter::operator()(void* ip_chunk)
  {
  SamplesChunk *p_chunk = static_cast<SamplesChunk*>(ip_chunk);
  MemoryPool *p_pool = p_chunk->GetMemoryPool();

  for(size_t i=0;i<p_chunk->GetNumberOfSamples();++i)
    {
    const Sample *p_sample = p_chunk->GetSample(i);
    Point2D_d image_point = p_sample->GetImagePoint();
    Point2D_d lens_uv = p_sample->GetLensUV();

    // Compute ray differentials by computing camera rays for adjacent image pixels.
    RayDifferential ray;
    Ray r_dx, r_dy;
    double weight = mp_camera->GenerateRay(image_point, lens_uv, ray.m_base_ray);
    double weight_dx = mp_camera->GenerateRay(image_point+Point2D_d(1.0, 0.0), lens_uv, r_dx);
    double weight_dy = mp_camera->GenerateRay(image_point+Point2D_d(0.0, 1.0), lens_uv, r_dy);

    if (weight_dx != 0.0 && weight_dy != 0.0)
      ray.m_has_differentials = true;

    ray.m_origin_dx=r_dx.m_origin;
    ray.m_origin_dy=r_dy.m_origin;
    ray.m_direction_dx=r_dx.m_direction;
    ray.m_direction_dy=r_dy.m_direction;

    Spectrum_d radiance=Spectrum_d(0.0);
    if (weight != 0.0)
      radiance = mp_renderer->Radiance(ray, p_sample, *p_pool);

    // Log unexpected radiance values.
    if (IsNaN(radiance))
      {
      if (mp_log)
        mp_log->LogMessage(Log::WARNING_LEVEL, "Not-a-number radiance value returned for image sample. Setting to black.");
      radiance = Spectrum_d(0.0);
      }
    else
      if (radiance.Luminance() < -DBL_EPS)
        {
        if (mp_log)
          mp_log->LogMessage(Log::WARNING_LEVEL, "Negative luminance value returned for image sample. Setting to black.");
        radiance = Spectrum_d(0.0);
        }
      else
        if (IsInf(radiance))
          {
          if (mp_log)
            mp_log->LogMessage(Log::WARNING_LEVEL, "Infinite spectrum value returned for image sample. Setting to black.");
          radiance = Spectrum_d(0.0);
          }

    p_chunk->SetRadiance(i, radiance * weight);

    // Free all allocated objects since we don't need them anymore at this point.
    p_pool->FreeAll();
    }

  return p_chunk;
  }

////////////////////////////////////////// FilmWriterFilter ///////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////

SamplerBasedRenderer::FilmWriterFilter::FilmWriterFilter(intrusive_ptr<Film> ip_film): tbb::filter(serial_out_of_order), mp_film(ip_film)
  {
  ASSERT(ip_film);
  }

void* SamplerBasedRenderer::FilmWriterFilter::operator()(void* ip_chunk)
  {
  SamplesChunk *p_chunk = static_cast<SamplesChunk*>(ip_chunk);

  for(size_t i=0;i<p_chunk->GetNumberOfSamples();++i)
    {
    const Sample *p_sample = p_chunk->GetSample(i);
    Spectrum_d radiance = p_chunk->GetRadiance(i);

    mp_film->AddSample(p_sample->GetImagePoint(), Convert<float>(radiance));
    }

  p_chunk->Release();
  return NULL;
  }